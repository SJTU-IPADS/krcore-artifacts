.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "IBV_WR API" "3" "2018\-11\-27" "libibverbs" "Libibverbs Programmer\[aq]s Manual"
.hy
.SH NAME
.PP
ibv_wr_abort, ibv_wr_complete, ibv_wr_start \- Manage regions allowed to
post work
.PP
ibv_wr_atomic_cmp_swp, ibv_wr_atomic_fetch_add \- Post remote atomic
operation work requests
.PP
ibv_wr_bind_mw, ibv_wr_local_inv \- Post work requests for memory
windows
.PP
ibv_wr_rdma_read, ibv_wr_rdma_write, ibv_wr_rdma_write_imm \- Post RDMA
work requests
.PP
ibv_wr_send, ibv_wr_send_imm, ibv_wr_send_inv \- Post send work requests
.PP
ibv_wr_send_tso \- Post segmentation offload work requests
.PP
ibv_wr_set_inline_data, ibv_wr_set_inline_data_list \- Attach inline
data to the last work request
.PP
ibv_wr_set_sge, ibv_wr_set_sge_list \- Attach data to the last work
request
.PP
ibv_wr_set_ud_addr \- Attach UD addressing info to the last work request
.PP
ibv_wr_set_xrc_srqn \- Attach an XRC SRQN to the last work request
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <infiniband/verbs.h>

void\ ibv_wr_abort(struct\ ibv_qp_ex\ *qp);
int\ ibv_wr_complete(struct\ ibv_qp_ex\ *qp);
void\ ibv_wr_start(struct\ ibv_qp_ex\ *qp);

void\ ibv_wr_atomic_cmp_swp(struct\ ibv_qp_ex\ *qp,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ remote_addr,\ uint64_t\ compare,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ swap);
void\ ibv_wr_atomic_fetch_add(struct\ ibv_qp_ex\ *qp,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ remote_addr,\ uint64_t\ add);

void\ ibv_wr_bind_mw(struct\ ibv_qp_ex\ *qp,\ struct\ ibv_mw\ *mw,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ struct\ ibv_mw_bind_info\ *bind_info);
void\ ibv_wr_local_inv(struct\ ibv_qp_ex\ *qp,\ uint32_t\ invalidate_rkey);

void\ ibv_wr_rdma_read(struct\ ibv_qp_ex\ *qp,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ remote_addr);
void\ ibv_wr_rdma_write(struct\ ibv_qp_ex\ *qp,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ remote_addr);
void\ ibv_wr_rdma_write_imm(struct\ ibv_qp_ex\ *qp,\ uint32_t\ rkey,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint64_t\ remote_addr,\ __be32\ imm_data);

void\ ibv_wr_send(struct\ ibv_qp_ex\ *qp);
void\ ibv_wr_send_imm(struct\ ibv_qp_ex\ *qp,\ __be32\ imm_data);
void\ ibv_wr_send_inv(struct\ ibv_qp_ex\ *qp,\ uint32_t\ invalidate_rkey);
void\ ibv_wr_send_tso(struct\ ibv_qp_ex\ *qp,\ void\ *hdr,\ uint16_t\ hdr_sz,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint16_t\ mss);

void\ ibv_wr_set_inline_data(struct\ ibv_qp_ex\ *qp,\ void\ *addr,\ size_t\ length);
void\ ibv_wr_set_inline_data_list(struct\ ibv_qp_ex\ *qp,\ size_t\ num_buf,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ struct\ ibv_data_buf\ *buf_list);
void\ ibv_wr_set_sge(struct\ ibv_qp_ex\ *qp,\ uint32_t\ lkey,\ uint64_t\ addr,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint32_t\ length);
void\ ibv_wr_set_sge_list(struct\ ibv_qp_ex\ *qp,\ size_t\ num_sge,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ struct\ ibv_sge\ *sg_list);

void\ ibv_wr_set_ud_addr(struct\ ibv_qp_ex\ *qp,\ struct\ ibv_ah\ *ah,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint32_t\ remote_qpn,\ uint32_t\ remote_qkey);
void\ ibv_wr_set_xrc_srqn(struct\ ibv_qp_ex\ *qp,\ uint32_t\ remote_srqn);
\f[]
.fi
.SH DESCRIPTION
.PP
The verbs work request API (ibv_wr_*) allows efficient posting of work
to a send queue using function calls instead of the struct based
\f[I]ibv_post_send()\f[] scheme.
This approach is designed to minimize CPU branching and locking during
the posting process.
.PP
This API is intended to be used to access additional functionality
beyond what is provided by \f[I]ibv_post_send()\f[].
.PP
WRs batches of \f[I]ibv_post_send()\f[] and this API WRs batches can
interleave together just if they are not posted within the critical
region of each other.
(A critical region in this API formed by \f[I]ibv_wr_start()\f[] and
\f[I]ibv_wr_complete()\f[]/\f[I]ibv_wr_abort()\f[])
.SH USAGE
.PP
To use these APIs the QP must be created using ibv_create_qp_ex() which
allows setting the \f[B]IBV_QP_INIT_ATTR_SEND_OPS_FLAGS\f[] in
\f[I]comp_mask\f[].
The \f[I]send_ops_flags\f[] should be set to the OR of the work request
types that will be posted to the QP.
.PP
If the QP does not support all the requested work request types then QP
creation will fail.
.PP
Posting work requests to the QP is done within the critical region
formed by \f[I]ibv_wr_start()\f[] and
\f[I]ibv_wr_complete()\f[]/\f[I]ibv_wr_abort()\f[] (see CONCURRENCY
below).
.PP
Each work request is created by calling a WR builder function (see the
table column WR builder below) to start creating the work request,
followed by allowed/required setter functions described below.
.PP
The WR builder and setter combination can be called multiple times to
efficiently post multiple work requests within a single critical region.
.PP
Each WR builder will use the \f[I]wr_id\f[] member of \f[I]struct
ibv_qp_ex\f[] to set the value to be returned in the completion.
Some operations will also use the \f[I]wr_flags\f[] member to influence
operation (see Flags below).
These values should be set before invoking the WR builder function.
.PP
For example a simple send could be formed as follows:
.IP
.nf
\f[C]
qpx\->wr_id\ =\ 1;
ibv_wr_send(qpx);
ibv_wr_set_sge(qpx,\ lkey,\ &data,\ sizeof(data));
\f[]
.fi
.PP
The section WORK REQUESTS describes the various WR builders and setters
in details.
.PP
Posting work is completed by calling \f[I]ibv_wr_complete()\f[] or
\f[I]ibv_wr_abort()\f[].
No work is executed to the queue until \f[I]ibv_wr_complete()\f[]
returns success.
\f[I]ibv_wr_abort()\f[] will discard all work prepared since
\f[I]ibv_wr_start()\f[].
.SH WORK REQUESTS
.PP
Many of the operations match the opcodes available for
\f[I]ibv_post_send()\f[].
Each operation has a WR builder function, a list of allowed setters, and
a flag bit to request the operation with \f[I]send_ops_flags\f[] in
\f[I]struct ibv_qp_init_attr_ex\f[] (see the EXAMPLE below).
.PP
.TS
tab(@);
l l l l.
T{
Operation
T}@T{
WR builder
T}@T{
QP Type Supported
T}@T{
setters
T}
_
T{
ATOMIC_CMP_AND_SWP
T}@T{
ibv_wr_atomic_cmp_swp()
T}@T{
RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
ATOMIC_FETCH_AND_ADD
T}@T{
ibv_wr_atomic_fetch_add()
T}@T{
RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
BIND_MW
T}@T{
ibv_wr_bind_mw()
T}@T{
UC, RC, XRC_SEND
T}@T{
NONE
T}
T{
LOCAL_INV
T}@T{
ibv_wr_local_inv()
T}@T{
UC, RC, XRC_SEND
T}@T{
NONE
T}
T{
RDMA_READ
T}@T{
ibv_wr_rdma_read()
T}@T{
RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
RDMA_WRITE
T}@T{
ibv_wr_rdma_write()
T}@T{
UC, RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
RDMA_WRITE_WITH_IMM
T}@T{
ibv_wr_rdma_write_imm()
T}@T{
UC, RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
SEND
T}@T{
ibv_wr_send()
T}@T{
UD, UC, RC, XRC_SEND, RAW_PACKET
T}@T{
DATA, QP
T}
T{
SEND_WITH_IMM
T}@T{
ibv_wr_send_imm()
T}@T{
UD, UC, RC, SRC SEND
T}@T{
DATA, QP
T}
T{
SEND_WITH_INV
T}@T{
ibv_wr_send_inv()
T}@T{
UC, RC, XRC_SEND
T}@T{
DATA, QP
T}
T{
TSO
T}@T{
ibv_wr_send_tso()
T}@T{
UD, RAW_PACKET
T}@T{
DATA, QP
T}
.TE
.SS Atomic operations
.PP
Atomic operations are only atomic so long as all writes to memory go
only through the same RDMA hardware.
It is not atomic with writes performed by the CPU, or by other RDMA
hardware in the system.
.TP
.B \f[I]ibv_wr_atomic_cmp_swp()\f[]
If the remote 64 bit memory location specified by \f[I]rkey\f[] and
\f[I]remote_addr\f[] equals \f[I]compare\f[] then set it to
\f[I]swap\f[].
.RS
.RE
.TP
.B \f[I]ibv_wr_atomic_fetch_add()\f[]
Add \f[I]add\f[] to the 64 bit memory location specified \f[I]rkey\f[]
and \f[I]remote_addr\f[].
.RS
.RE
.SS Memory Windows
.PP
Memory window type 2 operations (See man page for ibv_alloc_mw).
.TP
.B \f[I]ibv_wr_bind_mw()\f[]
Bind a MW type 2 specified by \f[B]mw\f[], set a new \f[B]rkey\f[] and
set its properties by \f[B]bind_info\f[].
.RS
.RE
.TP
.B \f[I]ibv_wr_local_inv()\f[]
Invalidate a MW type 2 which is associated with \f[B]rkey\f[].
.RS
.RE
.SS RDMA
.TP
.B \f[I]ibv_wr_rdma_read()\f[]
Read from the remote memory location specified \f[I]rkey\f[] and
\f[I]remote_addr\f[].
The number of bytes to read, and the local location to store the data,
is determined by the DATA buffers set after this call.
.RS
.RE
.TP
.B \f[I]ibv_wr_rdma_write()\f[], \f[I]ibv_wr_rdma_write_imm()\f[]
Write to the remote memory location specified \f[I]rkey\f[] and
\f[I]remote_addr\f[].
The number of bytes to read, and the local location to get the data, is
determined by the DATA buffers set after this call.
.RS
.PP
The _imm version causes the remote side to get a
IBV_WC_RECV_RDMA_WITH_IMM containing the 32 bits of immediate data.
.RE
.SS Message Send
.TP
.B \f[I]ibv_wr_send()\f[], \f[I]ibv_wr_send_imm()\f[]
Send a message.
The number of bytes to send, and the local location to get the data, is
determined by the DATA buffers set after this call.
.RS
.PP
The _imm version causes the remote side to get a
IBV_WC_RECV_RDMA_WITH_IMM containing the 32 bits of immediate data.
.RE
.TP
.B \f[I]ibv_wr_send_inv()\f[]
The data transfer is the same as for \f[I]ibv_wr_send()\f[], however the
remote side will invalidate the MR specified by \f[I]invalidate_rkey\f[]
before delivering a completion.
.RS
.RE
.TP
.B \f[I]ibv_wr_send_tso()\f[]
Produce multiple SEND messages using TCP Segmentation Offload.
The SGE points to a TCP Stream buffer which will be segmented into MSS
size SENDs.
The hdr includes the entire network headers up to and including the TCP
header and is prefixed before each segment.
.RS
.RE
.SS QP Specific setters
.PP
Certain QP types require each post to be accompanied by additional
setters, these setters are mandatory for any operation listing a QP
setter in the above table.
.TP
.B \f[I]UD\f[] QPs
\f[I]ibv_wr_set_ud_addr()\f[] must be called to set the destination
address of the work.
.RS
.RE
.TP
.B \f[I]XRC_SEND\f[] QPs
\f[I]ibv_wr_set_xrc_srqn()\f[] must be called to set the destination
SRQN field.
.RS
.RE
.SS DATA transfer setters
.PP
For work that requires to transfer data one of the following setters
should be called once after the WR builder:
.TP
.B \f[I]ibv_wr_set_sge()\f[]
Transfer data to/from a single buffer given by the lkey, addr and
length.
This is equivalent to \f[I]ibv_wr_set_sge_list()\f[] with a single
element.
.RS
.RE
.TP
.B \f[I]ibv_wr_set_sge_list()\f[]
Transfer data to/from a list of buffers, logically concatenated
together.
Each buffer is specified by an element in an array of \f[I]struct
ibv_sge\f[].
.RS
.RE
.PP
Inline setters will copy the send data during the setter and allows the
caller to immediately re\-use the buffer.
This behavior is identical to the IBV_SEND_INLINE flag.
Generally this copy is done in a way that optimizes SEND latency and is
suitable for small messages.
The provider will limit the amount of data it can support in a single
operation.
This limit is requested in the \f[I]max_inline_data\f[] member of
\f[I]struct ibv_qp_init_attr\f[].
Valid only for SEND and RDMA_WRITE.
.TP
.B \f[I]ibv_wr_set_inline_data()\f[]
Copy send data from a single buffer given by the addr and length.
This is equivalent to \f[I]ibv_wr_set_inline_data_list()\f[] with a
single element.
.RS
.RE
.TP
.B \f[I]ibv_wr_set_inline_data_list()\f[]
Copy send data from a list of buffers, logically concatenated together.
Each buffer is specified by an element in an array of \f[I]struct
ibv_inl_data\f[].
.RS
.RE
.SS Flags
.PP
A bit mask of flags may be specified in \f[I]wr_flags\f[] to control the
behavior of the work request.
.TP
.B \f[B]IBV_SEND_FENCE\f[]
Do not start this work request until prior work has completed.
.RS
.RE
.TP
.B \f[B]IBV_SEND_IP_CSUM\f[]
Offload the IPv4 and TCP/UDP checksum calculation
.RS
.RE
.TP
.B \f[B]IBV_SEND_SIGNALED\f[]
A completion will be generated in the completion queue for the
operation.
.RS
.RE
.TP
.B \f[B]IBV_SEND_SOLICTED\f[]
Set the solicted bit in the RDMA packet.
This informs the other side to generate a completion event upon
receiving the RDMA operation.
.RS
.RE
.SH CONCURRENCY
.PP
The provider will provide locking to ensure that \f[I]ibv_wr_start()\f[]
and \f[I]ibv_wr_complete()/abort()\f[] form a per\-QP critical section
where no other threads can enter.
.PP
If an \f[I]ibv_td\f[] is provided during QP creation then no locking
will be performed and it is up to the caller to ensure that only one
thread can be within the critical region at a time.
.SH RETURN VALUE
.PP
Applications should use this API in a way that does not create failures.
The individual APIs do not return a failure indication to avoid
branching.
.PP
If a failure is detected during operation, for instance due to an
invalid argument, then \f[I]ibv_wr_complete()\f[] will return failure
and the entire posting will be aborted.
.SH EXAMPLE
.IP
.nf
\f[C]
/*\ create\ RC\ QP\ type\ and\ specify\ the\ required\ send\ opcodes\ */
qp_init_attr_ex.qp_type\ =\ IBV_QPT_RC;
qp_init_attr_ex.comp_mask\ |=\ IBV_QP_INIT_ATTR_SEND_OPS_FLAGS;
qp_init_attr_ex.send_ops_flags\ |=\ IBV_QP_EX_WITH_RDMA_WRITE;
qp_init_attr_ex.send_ops_flags\ |=\ IBV_QP_EX_WITH_RDMA_WRITE_WITH_IMM;

ibv_qp\ *qp\ =\ ibv_create_qp_ex(ctx,\ qp_init_attr_ex);
ibv_qp_ex\ *qpx\ =\ ibv_qp_to_qp_ex(qp);

ibv_wr_start(qpx);

/*\ create\ 1st\ WRITE\ WR\ entry\ */
qpx\->wr_id\ =\ my_wr_id_1;
ibv_wr_rdma_write(qpx,\ rkey,\ remote_addr_1);
ibv_wr_set_sge(qpx,\ lkey,\ local_addr_1,\ length_1);

/*\ create\ 2nd\ WRITE_WITH_IMM\ WR\ entry\ */
qpx\->wr_id\ =\ my_wr_id_2;
qpx\->wr_flags\ =\ IBV_SEND_SIGNALED;
ibv_wr_rdma_write_imm(qpx,\ rkey,\ remote_addr_2,\ htonl(0x1234));
ibv_set_wr_sge(qpx,\ lkey,\ local_addr_2,\ length_2);

/*\ Begin\ processing\ WRs\ */
ret\ =\ ibv_wr_complete(qpx);
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]ibv_post_send\f[](3), \f[B]ibv_create_qp_ex(3)\f[].
.SH AUTHOR
.PP
Jason Gunthorpe <jgg@mellanox.com> Guy Levi <guyle@mellanox.com>
