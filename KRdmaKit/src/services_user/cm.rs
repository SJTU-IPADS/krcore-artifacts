extern crate serde;
extern crate serde_derive;
extern crate serde_json;

use crate::context::Context;
use crate::{CMError, QueuePair, QueuePairBuilder};

use hashbrown::HashMap;
use rdma_shim::bindings::*;
use rdma_shim::user::log;
use serde_derive::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::sync::Arc;
use std::thread;

use tokio::io;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::tcp::WriteHalf;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::Mutex;

#[derive(Copy, Clone, Serialize, Deserialize, Debug)]
pub enum CMReqType {
    RegReq(RCConnectionData),
    RegRes(RCConnectionData),
    DeregReq(u64),
}

/// `RCConnectionData` is used for remote QP to connect with it
#[derive(Copy, Clone, Serialize, Deserialize, Debug)]
pub struct RCConnectionData {
    pub lid: u32,
    pub gid: ibv_gid_wrapper,
    pub qpn: u32,
    pub starting_psn: u32,
    pub rnr_retry_count: u8,
    pub rc_key: u64, // for server-side indexing related qp
}

/// `ibv_gid_wrapper` is a wrapper of `ib_gid`(which is generated by `bindgen`), to derive `serde::Serialize` trait automatically.
///
/// Both `From<ib_gid>` and `Into<ib_gid>` are implemented for `ibv_gid_wrapper`.
///
/// Only for user-mode to use.
#[repr(C)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Serialize, Deserialize, Debug)]
pub struct ibv_gid_wrapper {
    raw: [u64; 2usize],
}

impl From<ib_gid> for ibv_gid_wrapper {
    fn from(gid: ib_gid) -> Self {
        Self {
            raw: gid.bindgen_union_field,
        }
    }
}

impl Into<ib_gid> for ibv_gid_wrapper {
    fn into(self) -> ib_gid {
        ib_gid {
            bindgen_union_field: self.raw,
            ..Default::default()
        }
    }
}

pub struct ConnectionManagerServer {
    registered_rc: Arc<Mutex<HashMap<u64, Arc<QueuePair>>>>,
    port_num: u8,
    ctx: Arc<Context>,
}

unsafe impl Send for ConnectionManagerServer {}
unsafe impl Sync for ConnectionManagerServer {}

/// ConnectionManagerServer in user-mode.
///
/// The server basically handles connection-requests and stores the incoming RC-QPs.
///
/// After receiving an RC-QP connection request,
/// it will automatically create a new one and store it in its `registered_rc`.
impl ConnectionManagerServer {
    /// Create an ConnectionManagerServer that listens to connection request and handles registration
    /// requests and de-registration request.
    ///
    /// Param `port_num` is the  RC-QP's port number to be created.
    ///
    /// Param `ctx` is corresponding to NIC you want to use.
    /// Pass different `ctx` created by `UDriver` to select a specific NIC to use or simultaneously use multiple-NICs
    ///
    /// Return an `Arc<ConnectionManagerServer>` for communicating usage.
    ///
    /// To make the server work, call `ConnectionManagerServer::spawn_rc_server`.
    pub fn new(ctx: &Arc<Context>, port_num: u8) -> Arc<Self> {
        Arc::new(Self {
            registered_rc: Arc::new(Default::default()),
            port_num,
            ctx: ctx.clone(),
        })
    }

    /// Spawn an listening thread to accept TCP connection and to handle RC-QP connection by this TCP stream.
    ///
    /// Param: `addr` is the socket address which the thread listens on.
    ///
    /// Return a `std::thread::JoinHandle<tokio::io::Result<()>>`
    /// The server thread will never exit unless something went wrong with the network IO (TCP stream).
    pub fn spawn_listener(
        self: &Arc<Self>,
        addr: SocketAddr,
    ) -> thread::JoinHandle<io::Result<()>> {
        let server = self.clone();
        thread::spawn(move || {
            tokio::runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .unwrap()
                .block_on(server.listener_inner(addr))
        })
    }
}

impl ConnectionManagerServer {
    async fn listener_inner(self: &Arc<Self>, addr: SocketAddr) -> io::Result<()> {
        let listener = TcpListener::bind(addr).await?;
        loop {
            let (stream, _) = listener.accept().await?;
            let server = self.clone();
            let _handle = tokio::spawn(server.service_handler(stream));
        }
    }

    // TODO : error handling
    async fn service_handler(self: Arc<Self>, mut stream: TcpStream) -> Result<(), CMError> {
        let mut buffer = [0; 1024];
        let (mut read, write) = stream.split();

        // 1. decode the connection data
        let bytes_read = read.read(&mut buffer).await.map_err(|_| {
            log::error!("IO error");
            CMError::Creation(0)
        })?;
        let req_type: CMReqType = serde_json::from_slice(&buffer[..bytes_read]).map_err(|_| {
            log::error!("Failed to do deserialization");
            CMError::Creation(0)
        })?;

        match req_type {
            CMReqType::RegReq(data) => self.handle_reg(write, data).await,
            CMReqType::RegRes(_) => {
                log::error!("Req type error");
                Err(CMError::Creation(0))
            }
            CMReqType::DeregReq(rc_key) => self.handle_dereg(rc_key).await,
        }
    }

    #[inline]
    async fn handle_reg(
        self: Arc<Self>,
        mut write: WriteHalf<'_>,
        data: RCConnectionData,
    ) -> Result<(), CMError> {
        let mut builder = QueuePairBuilder::new(&self.ctx);
        builder
            .set_rnr_retry(data.rnr_retry_count)
            .set_port_num(self.port_num)
            .set_max_send_wr(64) // not necessary to use a large WR: server QP is passive
            .allow_remote_rw()
            .allow_remote_atomic();
        let rc_qp = builder.build_rc().map_err(|_| {
            log::error!("Build rc error");
            CMError::Creation(0)
        })?;

        // directly bring this QP up
        let rc_qp = rc_qp
            .bring_up_rc(data.lid, data.gid.into(), data.qpn, data.starting_psn)
            .map_err(|_| {
                log::error!("Bring up rc error");
                CMError::Creation(0)
            })?;

        let rc_key = rc_qp.as_ref() as *const QueuePair as u64;

        let lid = rc_qp
            .ctx()
            .get_port_attr(self.port_num)
            .map_err(|err| CMError::Creation(err.to_kernel_errno()))?
            .lid as u32;

        let gid = rc_qp
            .ctx()
            .query_gid(self.port_num, 0) // FIXME: what if gid_index != 0?
            .map_err(|err| CMError::Creation(err.to_kernel_errno()))?;

        // send back
        let data = CMReqType::RegRes(RCConnectionData {
            lid,
            gid: ibv_gid_wrapper::from(gid),
            qpn: rc_qp.qp_num(),
            starting_psn: rc_qp.qp_num(),
            rnr_retry_count: data.rnr_retry_count,
            rc_key,
        });

        let serialized = serde_json::to_string(&data).map_err(|_| CMError::Creation(0))?;
        self.registered_rc.lock().await.insert(rc_key, rc_qp);
        write.write(&serialized.as_bytes()).await.map_err(|_| {
            log::error!("Send response error");
            CMError::Creation(0)
        })?;
        Ok(())
    }

    #[inline]
    async fn handle_dereg(self: Arc<Self>, rc_key: u64) -> Result<(), CMError> {
        self.registered_rc.lock().await.remove(&rc_key);
        Ok(())
    }
}
